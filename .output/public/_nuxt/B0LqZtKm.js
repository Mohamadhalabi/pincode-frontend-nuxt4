import{f as w,M as V,C as N,N as A,x as S,O as H,P as L,k as U,Q as M,R as W,S as j,T as q,h as R,U as z,V as I,W as G,X as Q,Y as X,Z as Y,_ as Z,$}from"./ClNtL1l2.js";const J={trailing:!0};function K(a,e=25,i={}){if(i={...J,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let s,n,u=[],r,t;const y=(d,h)=>(r=k(a,d,h),r.finally(()=>{if(r=null,i.trailing&&t&&!n){const m=y(d,t);return t=null,m}}),r),b=function(...d){return i.trailing&&(t=d),r||new Promise(h=>{const m=!n&&i.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const l=i.leading?s:y(this,d);t=null;for(const f of u)f(l);u=[]},e),m?(s=y(this,d),h(s)):u.push(h)})},o=d=>{d&&(clearTimeout(d),n=null)};return b.isPending=()=>!!n,b.cancel=()=>{o(n),u=[],t=null},b.flush=()=>{if(o(n),!t||r)return;const d=t;return t=null,y(this,d)},b}async function k(a,e,i){return await a.apply(e,i)}const aa=Symbol.for("nuxt:client-only");function oa(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;ea(a[0],a[1])&&a.unshift(e);let[i,s,n={}]=a,u=!1;const r=w(()=>V(i));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof s!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=N();n.server??=!0,n.default??=na,n.getCachedData??=F,n.lazy??=!1,n.immediate??=!0,n.deep??=A.deep,n.dedupe??="cancel",n._functionName,t._asyncData[r.value];function y(){const l={cause:"initial",dedupe:n.dedupe};return t._asyncData[r.value]?._init||(l.cachedData=n.getCachedData(r.value,t,{cause:"initial"}),t._asyncData[r.value]=T(t,r.value,s,n,l.cachedData)),()=>t._asyncData[r.value].execute(l)}const b=y(),o=t._asyncData[r.value];o._deps++;const d=n.server!==!1&&t.payload.serverRendered;{let l=function(c){const _=t._asyncData[c];_?._deps&&(_._deps--,_._deps===0&&_?._off())};const f=z();if(f&&d&&n.immediate&&!f.sp&&(f.sp=[]),f&&!f._nuxtOnBeforeMountCbs){f._nuxtOnBeforeMountCbs=[];const c=f._nuxtOnBeforeMountCbs;I(()=>{c.forEach(_=>{_()}),c.splice(0,c.length)}),G(()=>c.splice(0,c.length))}const D=f&&(f._nuxtClientOnly||Q(aa,!1));d&&t.isHydrating&&(o.error.value||o.data.value!==void 0)?o.status.value=o.error.value?"error":"success":f&&(!D&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?f._nuxtOnBeforeMountCbs.push(b):n.immediate&&o.status.value!=="success"&&b();const v=L(),C=S(r,(c,_)=>{if((c||_)&&c!==_){u=!0;const P=t._asyncData[_]?.data.value!==void 0,x=t._asyncDataPromises[_]!==void 0,O={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[c]?._init){let p;_&&P?p=t._asyncData[_].data.value:(p=n.getCachedData(c,t,{cause:"initial"}),O.cachedData=p),t._asyncData[c]=T(t,c,s,n,p)}t._asyncData[c]._deps++,_&&l(_),(n.immediate||P||x)&&t._asyncData[c].execute(O),X(()=>{u=!1})}},{flush:"sync"}),g=n.watch?S(n.watch,()=>{u||o._execute({cause:"watch",dedupe:n.dedupe})}):()=>{};v&&H(()=>{C(),g(),l(r.value)})}const h={data:E(()=>t._asyncData[r.value]?.data),pending:E(()=>t._asyncData[r.value]?.pending),status:E(()=>t._asyncData[r.value]?.status),error:E(()=>t._asyncData[r.value]?.error),refresh:(...l)=>t._asyncData[r.value]?._init?t._asyncData[r.value].execute(...l):y()(),execute:(...l)=>h.refresh(...l),clear:()=>{const l=t._asyncData[r.value];if(l?._abortController)try{l._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{l._abortController=void 0}B(t,r.value)}},m=Promise.resolve(t._asyncDataPromises[r.value]).then(()=>h);return Object.assign(m,h),m}function E(a){return w({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function ea(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}async function ia(a){await new Promise(i=>Y(i));const e=a?Z(a):void 0;await N().hooks.callHookParallel("app:data:refresh",e)}function B(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=R(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function ta(a,e){const i={};for(const s of e)i[s]=a[s];return i}function T(a,e,i,s,n){a.payload._errors[e]??=void 0;const u=s.getCachedData!==F,r=i,t=s.deep?U:M,y=n!==void 0,b=a.hook("app:data:refresh",async d=>{(!d||d.includes(e))&&await o.execute({cause:"refresh:hook"})}),o={data:t(y?n:s.default()),pending:w(()=>o.status.value==="pending"),error:W(a.payload._errors,e),status:M("idle"),execute:(...d)=>{const[h,m=void 0]=d,l=h&&m===void 0&&typeof h=="object"?h:{};if(a._asyncDataPromises[e]&&(l.dedupe??s.dedupe)==="defer")return a._asyncDataPromises[e];{const D="cachedData"in l?l.cachedData:s.getCachedData(e,a,{cause:l.cause??"refresh:manual"});if(D!==void 0)return a.payload.data[e]=o.data.value=D,o.error.value=void 0,o.status.value="success",Promise.resolve(D)}o._abortController&&o._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),o._abortController=new AbortController,o.status.value="pending";const f=new Promise((D,v)=>{try{const C=l.timeout??s.timeout,g=ra([o._abortController?.signal,l?.signal],C);if(g.aborted){const c=g.reason;v(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"));return}return g.addEventListener("abort",()=>{const c=g.reason;v(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"))},{once:!0}),Promise.resolve(r(a,{signal:g})).then(D,v)}catch(C){v(C)}}).then(async D=>{let v=D;s.transform&&(v=await s.transform(D)),s.pick&&(v=ta(v,s.pick)),a.payload.data[e]=v,o.data.value=v,o.error.value=void 0,o.status.value="success"}).catch(D=>{if(!(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==f)&&!o._abortController?.signal.aborted){if(typeof DOMException<"u"&&D instanceof DOMException&&D.name==="AbortError"){o.status.value="idle";return}o.error.value=q(D),o.data.value=R(s.default()),o.status.value="error"}}).finally(()=>{delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=f,a._asyncDataPromises[e]},_execute:K((...d)=>o.execute(...d),0,{leading:!0}),_default:s.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{b(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),u||j(()=>{a._asyncData[e]?._init||(B(a,e),o.execute=()=>Promise.resolve())})}};return o}const na=()=>{},F=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function ra(a,e){const i=a.filter(u=>!!u);if(typeof e=="number"&&e>=0){const u=AbortSignal.timeout?.(e);u&&i.push(u)}if(AbortSignal.any)return AbortSignal.any(i);const s=new AbortController;for(const u of i)if(u.aborted){const r=u.reason??new DOMException("Aborted","AbortError");try{s.abort(r)}catch{s.abort()}return s.signal}const n=()=>{const r=i.find(t=>t.aborted)?.reason??new DOMException("Aborted","AbortError");try{s.abort(r)}catch{s.abort()}};for(const u of i)u.addEventListener?.("abort",n,{once:!0});return s.signal}function ca(){const a=$("added-toast",()=>({open:!1,img:null,title:"",sku:null}));function e({img:i,title:s,sku:n}){a.value={open:!0,img:i||null,title:s,sku:n||null},setTimeout(()=>{a.value.open=!1},2500)}return{show:e}}export{oa as a,ia as r,ca as u};
