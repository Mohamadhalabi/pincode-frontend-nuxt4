import{f as P,K as q,B as T,L,M as U,N as V,O as H,P as I,x as S,Q as W,R as j,k as x,S as R,T as z,U as G,V as $,h as N,W as Q,X,Y,Z,e as J,$ as K,g as k}from"./CNQ7mN1-.js";const aa={trailing:!0};function ea(a,e=25,s={}){if(s={...aa,...s},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let o,t,c=[],r,n;const y=(d,h)=>(r=ta(a,d,h),r.finally(()=>{if(r=null,s.trailing&&n&&!t){const m=y(d,n);return n=null,m}}),r),b=function(...d){return s.trailing&&(n=d),r||new Promise(h=>{const m=!t&&s.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const l=s.leading?o:y(this,d);n=null;for(const f of c)f(l);c=[]},e),m?(o=y(this,d),h(o)):c.push(h)})},i=d=>{d&&(clearTimeout(d),t=null)};return b.isPending=()=>!!t,b.cancel=()=>{i(t),c=[],n=null},b.flush=()=>{if(i(t),!n||r)return;const d=n;return n=null,y(this,d)},b}async function ta(a,e,s){return await a.apply(e,s)}const na=Symbol.for("nuxt:client-only");function ua(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;ra(a[0],a[1])&&a.unshift(e);let[s,o,t={}]=a,c=!1;const r=P(()=>q(s));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const n=T();t.server??=!0,t.default??=oa,t.getCachedData??=A,t.lazy??=!1,t.immediate??=!0,t.deep??=L.deep,t.dedupe??="cancel",t._functionName,n._asyncData[r.value];function y(){const l={cause:"initial",dedupe:t.dedupe};return n._asyncData[r.value]?._init||(l.cachedData=t.getCachedData(r.value,n,{cause:"initial"}),n._asyncData[r.value]=M(n,r.value,o,t,l.cachedData)),()=>n._asyncData[r.value].execute(l)}const b=y(),i=n._asyncData[r.value];i._deps++;const d=t.server!==!1&&n.payload.serverRendered;{let l=function(u){const _=n._asyncData[u];_?._deps&&(_._deps--,_._deps===0&&_?._off())};const f=U();if(f&&d&&t.immediate&&!f.sp&&(f.sp=[]),f&&!f._nuxtOnBeforeMountCbs){f._nuxtOnBeforeMountCbs=[];const u=f._nuxtOnBeforeMountCbs;V(()=>{u.forEach(_=>{_()}),u.splice(0,u.length)}),H(()=>u.splice(0,u.length))}const D=f&&(f._nuxtClientOnly||I(na,!1));d&&n.isHydrating&&(i.error.value||i.data.value!==void 0)?i.status.value=i.error.value?"error":"success":f&&(!D&&n.payload.serverRendered&&n.isHydrating||t.lazy)&&t.immediate?f._nuxtOnBeforeMountCbs.push(b):t.immediate&&i.status.value!=="success"&&b();const v=j(),p=S(r,(u,_)=>{if((u||_)&&u!==_){c=!0;const w=n._asyncData[_]?.data.value!==void 0,F=n._asyncDataPromises[_]!==void 0,O={cause:"initial",dedupe:t.dedupe};if(!n._asyncData[u]?._init){let C;_&&w?C=n._asyncData[_].data.value:(C=t.getCachedData(u,n,{cause:"initial"}),O.cachedData=C),n._asyncData[u]=M(n,u,o,t,C)}n._asyncData[u]._deps++,_&&l(_),(t.immediate||w||F)&&n._asyncData[u].execute(O),Q(()=>{c=!1})}},{flush:"sync"}),g=t.watch?S(t.watch,()=>{c||i._execute({cause:"watch",dedupe:t.dedupe})}):()=>{};v&&W(()=>{p(),g(),l(r.value)})}const h={data:E(()=>n._asyncData[r.value]?.data),pending:E(()=>n._asyncData[r.value]?.pending),status:E(()=>n._asyncData[r.value]?.status),error:E(()=>n._asyncData[r.value]?.error),refresh:(...l)=>n._asyncData[r.value]?._init?n._asyncData[r.value].execute(...l):y()(),execute:(...l)=>h.refresh(...l),clear:()=>{const l=n._asyncData[r.value];if(l?._abortController)try{l._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{l._abortController=void 0}B(n,r.value)}},m=Promise.resolve(n._asyncDataPromises[r.value]).then(()=>h);return Object.assign(m,h),m}function E(a){return P({get(){return a()?.value},set(e){const s=a();s&&(s.value=e)}})}function ra(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}async function la(a){await new Promise(s=>X(s));const e=a?Y(a):void 0;await T().hooks.callHookParallel("app:data:refresh",e)}function B(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=N(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function sa(a,e){const s={};for(const o of e)s[o]=a[o];return s}function M(a,e,s,o,t){a.payload._errors[e]??=void 0;const c=o.getCachedData!==A,r=s,n=o.deep?x:R,y=t!==void 0,b=a.hook("app:data:refresh",async d=>{(!d||d.includes(e))&&await i.execute({cause:"refresh:hook"})}),i={data:n(y?t:o.default()),pending:P(()=>i.status.value==="pending"),error:z(a.payload._errors,e),status:R("idle"),execute:(...d)=>{const[h,m=void 0]=d,l=h&&m===void 0&&typeof h=="object"?h:{};if(a._asyncDataPromises[e]&&(l.dedupe??o.dedupe)==="defer")return a._asyncDataPromises[e];{const D="cachedData"in l?l.cachedData:o.getCachedData(e,a,{cause:l.cause??"refresh:manual"});if(D!==void 0)return a.payload.data[e]=i.data.value=D,i.error.value=void 0,i.status.value="success",Promise.resolve(D)}i._abortController&&i._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),i._abortController=new AbortController,i.status.value="pending";const f=new Promise((D,v)=>{try{const p=l.timeout??o.timeout,g=ia([i._abortController?.signal,l?.signal],p);if(g.aborted){const u=g.reason;v(u instanceof Error?u:new DOMException(String(u??"Aborted"),"AbortError"));return}return g.addEventListener("abort",()=>{const u=g.reason;v(u instanceof Error?u:new DOMException(String(u??"Aborted"),"AbortError"))},{once:!0}),Promise.resolve(r(a,{signal:g})).then(D,v)}catch(p){v(p)}}).then(async D=>{let v=D;o.transform&&(v=await o.transform(D)),o.pick&&(v=sa(v,o.pick)),a.payload.data[e]=v,i.data.value=v,i.error.value=void 0,i.status.value="success"}).catch(D=>{if(!(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==f)&&!i._abortController?.signal.aborted){if(typeof DOMException<"u"&&D instanceof DOMException&&D.name==="AbortError"){i.status.value="idle";return}i.error.value=$(D),i.data.value=N(o.default()),i.status.value="error"}}).finally(()=>{delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=f,a._asyncDataPromises[e]},_execute:ea((...d)=>i.execute(...d),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{b(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),c||G(()=>{a._asyncData[e]?._init||(B(a,e),i.execute=()=>Promise.resolve())})}};return i}const oa=()=>{},A=(a,e,s)=>{if(e.isHydrating)return e.payload.data[a];if(s.cause!=="refresh:manual"&&s.cause!=="refresh:hook")return e.static.data[a]};function ia(a,e){const s=a.filter(c=>!!c);if(typeof e=="number"&&e>=0){const c=AbortSignal.timeout?.(e);c&&s.push(c)}if(AbortSignal.any)return AbortSignal.any(s);const o=new AbortController;for(const c of s)if(c.aborted){const r=c.reason??new DOMException("Aborted","AbortError");try{o.abort(r)}catch{o.abort()}return o.signal}const t=()=>{const r=s.find(n=>n.aborted)?.reason??new DOMException("Aborted","AbortError");try{o.abort(r)}catch{o.abort()}};for(const c of s)c.addEventListener?.("abort",t,{once:!0});return o.signal}function da(){const a=Z("added-toast",()=>({open:!1,img:null,title:"",sku:null}));function e({img:s,title:o,sku:t}){a.value={open:!0,img:s||null,title:o,sku:t||null},setTimeout(()=>{a.value.open=!1},2500)}return{show:e}}const fa=()=>{const a=k(),{locale:e}=J(),s=K.create({baseURL:a.public.apiBase,headers:{Accept:"application/json"},retry:1,onResponseError(t){console.error("[API ERROR]",t.response.status,t.request,t.response._data)}});return{get:(t,c={})=>{const r={...c.query||{},lang:e.value};return s(t,{method:"GET",...c,query:r})},client:s}};export{fa as a,ua as b,la as r,da as u};
