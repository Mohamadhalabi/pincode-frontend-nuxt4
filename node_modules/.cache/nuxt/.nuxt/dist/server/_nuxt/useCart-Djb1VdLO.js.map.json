{"file":"useCart-Djb1VdLO.js","mappings":"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","names":["items"],"sources":["../../../../../../../composables/useCart.ts"],"sourcesContent":["// composables/useCart.ts\nimport { computed, onMounted, watch } from 'vue'\n\nexport type CartItem = {\n  id?: number\n  product_id: number\n  product_type: 'token-pack' | string\n  slug: string\n  sku?: string | null\n  name: string\n  price: number\n  qty: number\n  image?: string | null\n  meta?: Record<string, any> | null\n}\n\nconst STORAGE_KEY = 'pk:cart'\nconst makeKey = (it: Pick<CartItem, 'slug' | 'product_type' | 'product_id'>) =>\n  it.slug || `${it.product_type}:${it.product_id}`\n\nfunction unitPriceForQty(\n  qty: number,\n  meta?: Record<string, any> | null,\n  base?: number,\n  sale?: number\n): number {\n  const q = Math.max(1, Number(qty || 1))\n  const tiers = Array.isArray(meta?.pricing_tiers) ? [...(meta!.pricing_tiers as any[])] : []\n  tiers.sort((a: any, b: any) => (a?.min_qty || 1) - (b?.min_qty || 1))\n  for (const t of tiers) {\n    const min = Number(t?.min_qty || 1)\n    const max = t?.max_qty == null ? Number.POSITIVE_INFINITY : Number(t.max_qty)\n    if (q >= min && q <= max) return Number(t?.sale_price_usd ?? t?.price_usd ?? 0)\n  }\n  return Number((meta?.sale_price_usd ?? sale) ?? (meta?.base_price_usd ?? (meta as any)?.price_usd ?? base) ?? 0)\n}\n\nexport function useCart() {\n  const nuxt = useNuxtApp()\n  const $api: (<T = any>(p: string, o?: any) => Promise<T>) = (nuxt as any).$api\n\n  const state = useState('cart', () => ({\n    loaded: false,\n    items: [] as CartItem[],\n    map: new Map<string, CartItem>(), // maps composite key AND numeric id strings\n    subtotal: 0,\n  }))\n\n  const isAuthed = () =>\n    process.client && !!(localStorage.getItem('auth_token') || localStorage.getItem('pk:token'))\n\n  const persist = () => {\n    if (!process.client) return\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(state.value.items))\n    } catch {}\n  }\n\n  /** Reindex by composite key AND server numeric id (as string) */\n  const reindex = () => {\n    const items = state.value.items || []\n    const entries: [string, CartItem][] = []\n    for (const i of items) {\n      entries.push([makeKey(i), i])\n      if (i.id != null) entries.push([String(i.id), i])\n    }\n    state.value.map = new Map(entries)\n  }\n\n  const recalcSubtotal = () => {\n    const items = state.value.items || []\n    state.value.subtotal = items.reduce(\n      (s, it) => s + Number(it.price || 0) * Number(it.qty || 0),\n      0\n    )\n  }\n\n  onMounted(async () => {\n    if (state.value.loaded) return\n    if (isAuthed() && $api) {\n      await reload(true)\n    } else {\n      try {\n        const raw = process.client ? localStorage.getItem(STORAGE_KEY) : null\n        const arr = raw ? JSON.parse(raw) : []\n        state.value.items = Array.isArray(arr) ? arr : []\n      } catch {}\n      reindex()\n      recalcSubtotal()\n    }\n    state.value.loaded = true\n  })\n\n  watch(\n    () => state.value.items,\n    () => {\n      reindex()\n      persist()\n      recalcSubtotal()\n    },\n    { deep: true }\n  )\n\n  const items = computed<CartItem[]>(() => state.value.items || [])\n  const count = computed(() =>\n    (state.value.items || []).reduce((n, it) => n + Number(it.qty || 0), 0)\n  )\n  const subtotal = computed(() => Number(state.value.subtotal || 0))\n\n  function normalizeCartResponse(res: any) {\n    const box =\n      res?.data && (Array.isArray(res.data.items) || res.data.subtotal != null) ? res.data : res\n    const serverItems: CartItem[] = Array.isArray(box?.items) ? box.items : []\n    const serverSubtotal: number = Number(box?.subtotal ?? 0)\n    return { serverItems, serverSubtotal }\n  }\n\n  async function reload(fallbackToLocal = false) {\n    if (!isAuthed() || !$api) {\n      if (fallbackToLocal) {\n        try {\n          const raw = process.client ? localStorage.getItem(STORAGE_KEY) : null\n          state.value.items = raw ? JSON.parse(raw!) : []\n        } catch {\n          state.value.items = []\n        }\n        reindex()\n        recalcSubtotal()\n      }\n      return\n    }\n    try {\n      const res: any = await $api('/cart', { method: 'GET' })\n      const { serverItems, serverSubtotal } = normalizeCartResponse(res)\n      state.value.items = serverItems\n      state.value.subtotal = serverSubtotal\n      reindex()\n    } catch {\n      if (fallbackToLocal) {\n        try {\n          const raw = process.client ? localStorage.getItem(STORAGE_KEY) : null\n          state.value.items = raw ? JSON.parse(raw!) : []\n        } catch {\n          state.value.items = []\n        }\n        reindex()\n        recalcSubtotal()\n      }\n    }\n  }\n\n  async function mergeToServer() {\n    if (!isAuthed() || !$api) return\n    const guest = snapshot()\n    if (!guest.length) return\n    const payload = guest.map(i => ({\n      product_id: i.product_id,\n      product_type: i.product_type,\n      qty: Number(i.qty || 1),\n      name: i.name,\n      slug: i.slug ?? null,\n      sku: i.sku ?? null,\n      price: Number(i.price || 0),\n      image: i.image ?? null,\n      meta: i.meta ?? null,\n    }))\n    try {\n      await $api('/cart/merge', { method: 'POST', body: { items: payload } })\n    } catch {}\n  }\n\n  async function afterAuthSync() {\n    await mergeToServer()\n    await reload(true)\n  }\n\n  function addLocal(payload: CartItem | (Omit<CartItem, 'qty'> & { qty?: number })) {\n    const item: CartItem = {\n      qty: 1,\n      meta: null,\n      ...payload,\n      price: Number((payload as any).price || 0),\n    }\n    const key = makeKey(item)\n    const existed = state.value.map.get(key)\n    if (existed) {\n      existed.qty = Number(existed.qty || 0) + Number(item.qty || 1)\n      existed.price = unitPriceForQty(\n        existed.qty,\n        existed.meta,\n        (existed.meta as any)?.base_price_usd,\n        (existed.meta as any)?.sale_price_usd\n      )\n    } else {\n      state.value.items.push({ ...item, qty: Number(item.qty || 1) })\n    }\n    recalcSubtotal()\n  }\n\n  function setQtyLocal(keyOrItem: string | number | CartItem, qty: number) {\n    const it = resolveItem(keyOrItem)\n    if (!it) return\n    it.qty = Math.max(1, Math.floor(Number(qty) || 1))\n    it.price = unitPriceForQty(\n      it.qty,\n      it.meta,\n      (it.meta as any)?.base_price_usd,\n      (it.meta as any)?.sale_price_usd\n    )\n    recalcSubtotal()\n  }\n\n  function removeLocal(keyOrItem: string | number | CartItem) {\n    const it = resolveItem(keyOrItem)\n    if (!it) return\n    const idx = (state.value.items || []).findIndex(i => i === it)\n    if (idx >= 0) state.value.items.splice(idx, 1)\n    recalcSubtotal()\n  }\n\n  async function add(payload: CartItem | (Omit<CartItem, 'qty'> & { qty?: number })) {\n    if (!isAuthed() || !$api) return addLocal(payload)\n    const body = {\n      product_id: payload.product_id,\n      product_type: payload.product_type,\n      slug: payload.slug ?? null,\n      sku: payload.sku ?? null,\n      name: payload.name,\n      price: Number((payload as any).price || 0),\n      qty: Number((payload as any).qty || 1),\n      image: (payload as any).image ?? null,\n      meta: (payload as any).meta ?? null,\n    }\n    await $api('/cart/items', { method: 'POST', body })\n    await reload()\n  }\n\n  /** ---------- Helpers to resolve any key â†’ item ---------- */\n  function resolveItem(keyOrItem: string | number | CartItem): CartItem | undefined {\n    if (!keyOrItem) return undefined\n    if (typeof keyOrItem === 'object') return keyOrItem as CartItem\n    // try direct map\n    const byMap = state.value.map.get(String(keyOrItem))\n    if (byMap) return byMap\n    // try find by composite or id\n    const items = state.value.items || []\n    if (typeof keyOrItem === 'string') {\n      return items.find(i => makeKey(i) === keyOrItem)\n    } else {\n      const idNum = Number(keyOrItem)\n      return items.find(i => Number(i.id) === idNum)\n    }\n  }\n\n  /** ---------- SERVER actions now accept string | number | CartItem ---------- */\n  async function setQty(keyOrItem: string | number | CartItem, qty: number) {\n    qty = Math.max(1, Math.floor(Number(qty) || 1))\n    if (!isAuthed() || !$api) return setQtyLocal(keyOrItem, qty)\n\n    const item = resolveItem(keyOrItem)\n    if (!item) return\n\n    await $api('/cart/items/update', {\n      method: 'POST',\n      body: { product_id: item.product_id, product_type: item.product_type, qty },\n    })\n    await reload()\n  }\n\n  async function remove(keyOrItem: string | number | CartItem) {\n    if (!isAuthed() || !$api) return removeLocal(keyOrItem)\n\n    const item = resolveItem(keyOrItem)\n    if (!item) return\n\n    await $api('/cart/items/remove', {\n      method: 'POST',\n      body: { product_id: item.product_id, product_type: item.product_type },\n    })\n    await reload()\n  }\n\n  async function clear() {\n    if (!isAuthed() || !$api) {\n      state.value.items.splice(0, state.value.items.length)\n      state.value.subtotal = 0\n      persist()\n      return\n    }\n    const snapshotItems = [...(state.value.items || [])]\n    for (const it of snapshotItems) {\n      await $api('/cart/items/remove', {\n        method: 'POST',\n        body: { product_id: it.product_id, product_type: it.product_type },\n      })\n    }\n    await reload()\n  }\n\n  function replace(nextItems: CartItem[]) {\n    state.value.items.splice(0, state.value.items.length, ...nextItems)\n    recalcSubtotal()\n  }\n\n  function snapshot(): CartItem[] {\n    return (state.value.items || []).map(i => ({ ...i, meta: i.meta ? { ...i.meta } : null }))\n  }\n\n  function sync() {\n    persist()\n  }\n\n  return {\n    items,\n    count,\n    subtotal,\n    add,\n    setQty,\n    remove,\n    clear,\n    replace,\n    snapshot,\n    reload,\n    mergeToServer,\n    afterAuthSync,\n    sync,\n    makeKey,\n  }\n}\n"],"version":3}